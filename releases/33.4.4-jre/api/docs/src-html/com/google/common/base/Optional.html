<!DOCTYPE HTML>
<html lang>
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> * Copyright (C) 2011 The Guava Authors</a>
<span class="sourceLineNo">003</span><a id="line.3"> *</a>
<span class="sourceLineNo">004</span><a id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except</a>
<span class="sourceLineNo">005</span><a id="line.5"> * in compliance with the License. You may obtain a copy of the License at</a>
<span class="sourceLineNo">006</span><a id="line.6"> *</a>
<span class="sourceLineNo">007</span><a id="line.7"> * http://www.apache.org/licenses/LICENSE-2.0</a>
<span class="sourceLineNo">008</span><a id="line.8"> *</a>
<span class="sourceLineNo">009</span><a id="line.9"> * Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<span class="sourceLineNo">010</span><a id="line.10"> * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<span class="sourceLineNo">011</span><a id="line.11"> * or implied. See the License for the specific language governing permissions and limitations under</a>
<span class="sourceLineNo">012</span><a id="line.12"> * the License.</a>
<span class="sourceLineNo">013</span><a id="line.13"> */</a>
<span class="sourceLineNo">014</span><a id="line.14"></a>
<span class="sourceLineNo">015</span><a id="line.15">package com.google.common.base;</a>
<span class="sourceLineNo">016</span><a id="line.16"></a>
<span class="sourceLineNo">017</span><a id="line.17">import static com.google.common.base.Preconditions.checkNotNull;</a>
<span class="sourceLineNo">018</span><a id="line.18"></a>
<span class="sourceLineNo">019</span><a id="line.19">import com.google.common.annotations.GwtCompatible;</a>
<span class="sourceLineNo">020</span><a id="line.20">import com.google.errorprone.annotations.DoNotMock;</a>
<span class="sourceLineNo">021</span><a id="line.21">import java.io.Serializable;</a>
<span class="sourceLineNo">022</span><a id="line.22">import java.util.Iterator;</a>
<span class="sourceLineNo">023</span><a id="line.23">import java.util.Set;</a>
<span class="sourceLineNo">024</span><a id="line.24">import org.jspecify.annotations.Nullable;</a>
<span class="sourceLineNo">025</span><a id="line.25"></a>
<span class="sourceLineNo">026</span><a id="line.26">/**</a>
<span class="sourceLineNo">027</span><a id="line.27"> * An immutable object that may contain a non-null reference to another object. Each instance of</a>
<span class="sourceLineNo">028</span><a id="line.28"> * this type either contains a non-null reference, or contains nothing (in which case we say that</a>
<span class="sourceLineNo">029</span><a id="line.29"> * the reference is "absent"); it is never said to "contain {@code null}".</a>
<span class="sourceLineNo">030</span><a id="line.30"> *</a>
<span class="sourceLineNo">031</span><a id="line.31"> * &lt;p&gt;A non-null {@code Optional&lt;T&gt;} reference can be used as a replacement for a nullable {@code T}</a>
<span class="sourceLineNo">032</span><a id="line.32"> * reference. It allows you to represent "a {@code T} that must be present" and a "a {@code T} that</a>
<span class="sourceLineNo">033</span><a id="line.33"> * might be absent" as two distinct types in your program, which can aid clarity.</a>
<span class="sourceLineNo">034</span><a id="line.34"> *</a>
<span class="sourceLineNo">035</span><a id="line.35"> * &lt;p&gt;Some uses of this class include</a>
<span class="sourceLineNo">036</span><a id="line.36"> *</a>
<span class="sourceLineNo">037</span><a id="line.37"> * &lt;ul&gt;</a>
<span class="sourceLineNo">038</span><a id="line.38"> *   &lt;li&gt;As a method return type, as an alternative to returning {@code null} to indicate that no</a>
<span class="sourceLineNo">039</span><a id="line.39"> *       value was available</a>
<span class="sourceLineNo">040</span><a id="line.40"> *   &lt;li&gt;To distinguish between "unknown" (for example, not present in a map) and "known to have no</a>
<span class="sourceLineNo">041</span><a id="line.41"> *       value" (present in the map, with value {@code Optional.absent()})</a>
<span class="sourceLineNo">042</span><a id="line.42"> *   &lt;li&gt;To wrap nullable references for storage in a collection that does not support {@code null}</a>
<span class="sourceLineNo">043</span><a id="line.43"> *       (though there are &lt;a</a>
<span class="sourceLineNo">044</span><a id="line.44"> *       href="https://github.com/google/guava/wiki/LivingWithNullHostileCollections"&gt;several other</a>
<span class="sourceLineNo">045</span><a id="line.45"> *       approaches to this&lt;/a&gt; that should be considered first)</a>
<span class="sourceLineNo">046</span><a id="line.46"> * &lt;/ul&gt;</a>
<span class="sourceLineNo">047</span><a id="line.47"> *</a>
<span class="sourceLineNo">048</span><a id="line.48"> * &lt;p&gt;A common alternative to using this class is to find or create a suitable &lt;a</a>
<span class="sourceLineNo">049</span><a id="line.49"> * href="http://en.wikipedia.org/wiki/Null_Object_pattern"&gt;null object&lt;/a&gt; for the type in question.</a>
<span class="sourceLineNo">050</span><a id="line.50"> *</a>
<span class="sourceLineNo">051</span><a id="line.51"> * &lt;p&gt;This class is not intended as a direct analogue of any existing "option" or "maybe" construct</a>
<span class="sourceLineNo">052</span><a id="line.52"> * from other programming environments, though it may bear some similarities.</a>
<span class="sourceLineNo">053</span><a id="line.53"> *</a>
<span class="sourceLineNo">054</span><a id="line.54"> * &lt;p&gt;An instance of this class is serializable if its reference is absent or is a serializable</a>
<span class="sourceLineNo">055</span><a id="line.55"> * object.</a>
<span class="sourceLineNo">056</span><a id="line.56"> *</a>
<span class="sourceLineNo">057</span><a id="line.57"> * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional} (JDK 8 and higher):&lt;/b&gt; A new {@code Optional}</a>
<span class="sourceLineNo">058</span><a id="line.58"> * class was added for Java 8. The two classes are extremely similar, but incompatible (they cannot</a>
<span class="sourceLineNo">059</span><a id="line.59"> * share a common supertype). &lt;i&gt;All&lt;/i&gt; known differences are listed either here or with the</a>
<span class="sourceLineNo">060</span><a id="line.60"> * relevant methods below.</a>
<span class="sourceLineNo">061</span><a id="line.61"> *</a>
<span class="sourceLineNo">062</span><a id="line.62"> * &lt;ul&gt;</a>
<span class="sourceLineNo">063</span><a id="line.63"> *   &lt;li&gt;This class is serializable; {@code java.util.Optional} is not.</a>
<span class="sourceLineNo">064</span><a id="line.64"> *   &lt;li&gt;{@code java.util.Optional} has the additional methods {@code ifPresent}, {@code filter},</a>
<span class="sourceLineNo">065</span><a id="line.65"> *       {@code flatMap}, and {@code orElseThrow}.</a>
<span class="sourceLineNo">066</span><a id="line.66"> *   &lt;li&gt;{@code java.util} offers the primitive-specialized versions {@code OptionalInt}, {@code</a>
<span class="sourceLineNo">067</span><a id="line.67"> *       OptionalLong} and {@code OptionalDouble}, the use of which is recommended; Guava does not</a>
<span class="sourceLineNo">068</span><a id="line.68"> *       have these.</a>
<span class="sourceLineNo">069</span><a id="line.69"> * &lt;/ul&gt;</a>
<span class="sourceLineNo">070</span><a id="line.70"> *</a>
<span class="sourceLineNo">071</span><a id="line.71"> * &lt;p&gt;&lt;b&gt;There are no plans to deprecate this class in the foreseeable future.&lt;/b&gt; However, we do</a>
<span class="sourceLineNo">072</span><a id="line.72"> * gently recommend that you prefer the new, standard Java class whenever possible.</a>
<span class="sourceLineNo">073</span><a id="line.73"> *</a>
<span class="sourceLineNo">074</span><a id="line.74"> * &lt;p&gt;See the Guava User Guide article on &lt;a</a>
<span class="sourceLineNo">075</span><a id="line.75"> * href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained#optional"&gt;using {@code</a>
<span class="sourceLineNo">076</span><a id="line.76"> * Optional}&lt;/a&gt;.</a>
<span class="sourceLineNo">077</span><a id="line.77"> *</a>
<span class="sourceLineNo">078</span><a id="line.78"> * @param &lt;T&gt; the type of instance that can be contained. {@code Optional} is naturally covariant on</a>
<span class="sourceLineNo">079</span><a id="line.79"> *     this type, so it is safe to cast an {@code Optional&lt;T&gt;} to {@code Optional&lt;S&gt;} for any</a>
<span class="sourceLineNo">080</span><a id="line.80"> *     supertype {@code S} of {@code T}.</a>
<span class="sourceLineNo">081</span><a id="line.81"> * @author Kurt Alfred Kluever</a>
<span class="sourceLineNo">082</span><a id="line.82"> * @author Kevin Bourrillion</a>
<span class="sourceLineNo">083</span><a id="line.83"> * @since 10.0</a>
<span class="sourceLineNo">084</span><a id="line.84"> */</a>
<span class="sourceLineNo">085</span><a id="line.85">@DoNotMock("Use Optional.of(value) or Optional.absent()")</a>
<span class="sourceLineNo">086</span><a id="line.86">@GwtCompatible(serializable = true)</a>
<span class="sourceLineNo">087</span><a id="line.87">public abstract class Optional&lt;T&gt; implements Serializable {</a>
<span class="sourceLineNo">088</span><a id="line.88">  /**</a>
<span class="sourceLineNo">089</span><a id="line.89">   * Returns an {@code Optional} instance with no contained reference.</a>
<span class="sourceLineNo">090</span><a id="line.90">   *</a>
<span class="sourceLineNo">091</span><a id="line.91">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method is equivalent to Java 8's</a>
<span class="sourceLineNo">092</span><a id="line.92">   * {@code Optional.empty}.</a>
<span class="sourceLineNo">093</span><a id="line.93">   */</a>
<span class="sourceLineNo">094</span><a id="line.94">  public static &lt;T&gt; Optional&lt;T&gt; absent() {</a>
<span class="sourceLineNo">095</span><a id="line.95">    return Absent.withType();</a>
<span class="sourceLineNo">096</span><a id="line.96">  }</a>
<span class="sourceLineNo">097</span><a id="line.97"></a>
<span class="sourceLineNo">098</span><a id="line.98">  /**</a>
<span class="sourceLineNo">099</span><a id="line.99">   * Returns an {@code Optional} instance containing the given non-null reference. To have {@code</a>
<span class="sourceLineNo">100</span><a id="line.100">   * null} treated as {@link #absent}, use {@link #fromNullable} instead.</a>
<span class="sourceLineNo">101</span><a id="line.101">   *</a>
<span class="sourceLineNo">102</span><a id="line.102">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; no differences.</a>
<span class="sourceLineNo">103</span><a id="line.103">   *</a>
<span class="sourceLineNo">104</span><a id="line.104">   * @throws NullPointerException if {@code reference} is null</a>
<span class="sourceLineNo">105</span><a id="line.105">   */</a>
<span class="sourceLineNo">106</span><a id="line.106">  public static &lt;T&gt; Optional&lt;T&gt; of(T reference) {</a>
<span class="sourceLineNo">107</span><a id="line.107">    return new Present&lt;&gt;(checkNotNull(reference));</a>
<span class="sourceLineNo">108</span><a id="line.108">  }</a>
<span class="sourceLineNo">109</span><a id="line.109"></a>
<span class="sourceLineNo">110</span><a id="line.110">  /**</a>
<span class="sourceLineNo">111</span><a id="line.111">   * If {@code nullableReference} is non-null, returns an {@code Optional} instance containing that</a>
<span class="sourceLineNo">112</span><a id="line.112">   * reference; otherwise returns {@link Optional#absent}.</a>
<span class="sourceLineNo">113</span><a id="line.113">   *</a>
<span class="sourceLineNo">114</span><a id="line.114">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method is equivalent to Java 8's</a>
<span class="sourceLineNo">115</span><a id="line.115">   * {@code Optional.ofNullable}.</a>
<span class="sourceLineNo">116</span><a id="line.116">   */</a>
<span class="sourceLineNo">117</span><a id="line.117">  public static &lt;T&gt; Optional&lt;T&gt; fromNullable(@Nullable T nullableReference) {</a>
<span class="sourceLineNo">118</span><a id="line.118">    return (nullableReference == null) ? Optional.&lt;T&gt;absent() : new Present&lt;T&gt;(nullableReference);</a>
<span class="sourceLineNo">119</span><a id="line.119">  }</a>
<span class="sourceLineNo">120</span><a id="line.120"></a>
<span class="sourceLineNo">121</span><a id="line.121">  /**</a>
<span class="sourceLineNo">122</span><a id="line.122">   * Returns the equivalent {@code com.google.common.base.Optional} value to the given {@code</a>
<span class="sourceLineNo">123</span><a id="line.123">   * java.util.Optional}, or {@code null} if the argument is null.</a>
<span class="sourceLineNo">124</span><a id="line.124">   *</a>
<span class="sourceLineNo">125</span><a id="line.125">   * @since 21.0 (but only since 33.4.0 in the Android flavor)</a>
<span class="sourceLineNo">126</span><a id="line.126">   */</a>
<span class="sourceLineNo">127</span><a id="line.127">  public static &lt;T&gt; @Nullable Optional&lt;T&gt; fromJavaUtil(</a>
<span class="sourceLineNo">128</span><a id="line.128">      java.util.@Nullable Optional&lt;T&gt; javaUtilOptional) {</a>
<span class="sourceLineNo">129</span><a id="line.129">    return (javaUtilOptional == null) ? null : fromNullable(javaUtilOptional.orElse(null));</a>
<span class="sourceLineNo">130</span><a id="line.130">  }</a>
<span class="sourceLineNo">131</span><a id="line.131"></a>
<span class="sourceLineNo">132</span><a id="line.132">  /**</a>
<span class="sourceLineNo">133</span><a id="line.133">   * Returns the equivalent {@code java.util.Optional} value to the given {@code</a>
<span class="sourceLineNo">134</span><a id="line.134">   * com.google.common.base.Optional}, or {@code null} if the argument is null.</a>
<span class="sourceLineNo">135</span><a id="line.135">   *</a>
<span class="sourceLineNo">136</span><a id="line.136">   * &lt;p&gt;If {@code googleOptional} is known to be non-null, use {@code googleOptional.toJavaUtil()}</a>
<span class="sourceLineNo">137</span><a id="line.137">   * instead.</a>
<span class="sourceLineNo">138</span><a id="line.138">   *</a>
<span class="sourceLineNo">139</span><a id="line.139">   * &lt;p&gt;Unfortunately, the method reference {@code Optional::toJavaUtil} will not work, because it</a>
<span class="sourceLineNo">140</span><a id="line.140">   * could refer to either the static or instance version of this method. Write out the lambda</a>
<span class="sourceLineNo">141</span><a id="line.141">   * expression {@code o -&gt; Optional.toJavaUtil(o)} instead.</a>
<span class="sourceLineNo">142</span><a id="line.142">   *</a>
<span class="sourceLineNo">143</span><a id="line.143">   * @since 21.0 (but only since 33.4.0 in the Android flavor)</a>
<span class="sourceLineNo">144</span><a id="line.144">   */</a>
<span class="sourceLineNo">145</span><a id="line.145">  @SuppressWarnings("AmbiguousMethodReference") // We chose the name despite knowing this risk.</a>
<span class="sourceLineNo">146</span><a id="line.146">  public static &lt;T&gt; java.util.@Nullable Optional&lt;T&gt; toJavaUtil(</a>
<span class="sourceLineNo">147</span><a id="line.147">      @Nullable Optional&lt;T&gt; googleOptional) {</a>
<span class="sourceLineNo">148</span><a id="line.148">    return googleOptional == null ? null : googleOptional.toJavaUtil();</a>
<span class="sourceLineNo">149</span><a id="line.149">  }</a>
<span class="sourceLineNo">150</span><a id="line.150"></a>
<span class="sourceLineNo">151</span><a id="line.151">  /**</a>
<span class="sourceLineNo">152</span><a id="line.152">   * Returns the equivalent {@code java.util.Optional} value to this optional.</a>
<span class="sourceLineNo">153</span><a id="line.153">   *</a>
<span class="sourceLineNo">154</span><a id="line.154">   * &lt;p&gt;Unfortunately, the method reference {@code Optional::toJavaUtil} will not work, because it</a>
<span class="sourceLineNo">155</span><a id="line.155">   * could refer to either the static or instance version of this method. Write out the lambda</a>
<span class="sourceLineNo">156</span><a id="line.156">   * expression {@code o -&gt; o.toJavaUtil()} instead.</a>
<span class="sourceLineNo">157</span><a id="line.157">   *</a>
<span class="sourceLineNo">158</span><a id="line.158">   * @since 21.0 (but only since 33.4.0 in the Android flavor)</a>
<span class="sourceLineNo">159</span><a id="line.159">   */</a>
<span class="sourceLineNo">160</span><a id="line.160">  @SuppressWarnings("AmbiguousMethodReference") // We chose the name despite knowing this risk.</a>
<span class="sourceLineNo">161</span><a id="line.161">  public java.util.Optional&lt;T&gt; toJavaUtil() {</a>
<span class="sourceLineNo">162</span><a id="line.162">    return java.util.Optional.ofNullable(orNull());</a>
<span class="sourceLineNo">163</span><a id="line.163">  }</a>
<span class="sourceLineNo">164</span><a id="line.164"></a>
<span class="sourceLineNo">165</span><a id="line.165">  Optional() {}</a>
<span class="sourceLineNo">166</span><a id="line.166"></a>
<span class="sourceLineNo">167</span><a id="line.167">  /**</a>
<span class="sourceLineNo">168</span><a id="line.168">   * Returns {@code true} if this holder contains a (non-null) instance.</a>
<span class="sourceLineNo">169</span><a id="line.169">   *</a>
<span class="sourceLineNo">170</span><a id="line.170">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; no differences.</a>
<span class="sourceLineNo">171</span><a id="line.171">   */</a>
<span class="sourceLineNo">172</span><a id="line.172">  public abstract boolean isPresent();</a>
<span class="sourceLineNo">173</span><a id="line.173"></a>
<span class="sourceLineNo">174</span><a id="line.174">  /**</a>
<span class="sourceLineNo">175</span><a id="line.175">   * Returns the contained instance, which must be present. If the instance might be absent, use</a>
<span class="sourceLineNo">176</span><a id="line.176">   * {@link #or(Object)} or {@link #orNull} instead.</a>
<span class="sourceLineNo">177</span><a id="line.177">   *</a>
<span class="sourceLineNo">178</span><a id="line.178">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; when the value is absent, this method</a>
<span class="sourceLineNo">179</span><a id="line.179">   * throws {@link IllegalStateException}, whereas the {@code java.util} counterpart throws {@link</a>
<span class="sourceLineNo">180</span><a id="line.180">   * java.util.NoSuchElementException NoSuchElementException}.</a>
<span class="sourceLineNo">181</span><a id="line.181">   *</a>
<span class="sourceLineNo">182</span><a id="line.182">   * @throws IllegalStateException if the instance is absent ({@link #isPresent} returns {@code</a>
<span class="sourceLineNo">183</span><a id="line.183">   *     false}); depending on this &lt;i&gt;specific&lt;/i&gt; exception type (over the more general {@link</a>
<span class="sourceLineNo">184</span><a id="line.184">   *     RuntimeException}) is discouraged</a>
<span class="sourceLineNo">185</span><a id="line.185">   */</a>
<span class="sourceLineNo">186</span><a id="line.186">  public abstract T get();</a>
<span class="sourceLineNo">187</span><a id="line.187"></a>
<span class="sourceLineNo">188</span><a id="line.188">  /**</a>
<span class="sourceLineNo">189</span><a id="line.189">   * Returns the contained instance if it is present; {@code defaultValue} otherwise. If no default</a>
<span class="sourceLineNo">190</span><a id="line.190">   * value should be required because the instance is known to be present, use {@link #get()}</a>
<span class="sourceLineNo">191</span><a id="line.191">   * instead. For a default value of {@code null}, use {@link #orNull}.</a>
<span class="sourceLineNo">192</span><a id="line.192">   *</a>
<span class="sourceLineNo">193</span><a id="line.193">   * &lt;p&gt;Note about generics: The signature {@code public T or(T defaultValue)} is overly</a>
<span class="sourceLineNo">194</span><a id="line.194">   * restrictive. However, the ideal signature, {@code public &lt;S super T&gt; S or(S)}, is not legal</a>
<span class="sourceLineNo">195</span><a id="line.195">   * Java. As a result, some sensible operations involving subtypes are compile errors:</a>
<span class="sourceLineNo">196</span><a id="line.196">   *</a>
<span class="sourceLineNo">197</span><a id="line.197">   * &lt;pre&gt;{@code</a>
<span class="sourceLineNo">198</span><a id="line.198">   * Optional&lt;Integer&gt; optionalInt = getSomeOptionalInt();</a>
<span class="sourceLineNo">199</span><a id="line.199">   * Number value = optionalInt.or(0.5); // error</a>
<span class="sourceLineNo">200</span><a id="line.200">   *</a>
<span class="sourceLineNo">201</span><a id="line.201">   * FluentIterable&lt;? extends Number&gt; numbers = getSomeNumbers();</a>
<span class="sourceLineNo">202</span><a id="line.202">   * Optional&lt;? extends Number&gt; first = numbers.first();</a>
<span class="sourceLineNo">203</span><a id="line.203">   * Number value = first.or(0.5); // error</a>
<span class="sourceLineNo">204</span><a id="line.204">   * }&lt;/pre&gt;</a>
<span class="sourceLineNo">205</span><a id="line.205">   *</a>
<span class="sourceLineNo">206</span><a id="line.206">   * &lt;p&gt;As a workaround, it is always safe to cast an {@code Optional&lt;? extends T&gt;} to {@code</a>
<span class="sourceLineNo">207</span><a id="line.207">   * Optional&lt;T&gt;}. Casting either of the above example {@code Optional} instances to {@code</a>
<span class="sourceLineNo">208</span><a id="line.208">   * Optional&lt;Number&gt;} (where {@code Number} is the desired output type) solves the problem:</a>
<span class="sourceLineNo">209</span><a id="line.209">   *</a>
<span class="sourceLineNo">210</span><a id="line.210">   * &lt;pre&gt;{@code</a>
<span class="sourceLineNo">211</span><a id="line.211">   * Optional&lt;Number&gt; optionalInt = (Optional) getSomeOptionalInt();</a>
<span class="sourceLineNo">212</span><a id="line.212">   * Number value = optionalInt.or(0.5); // fine</a>
<span class="sourceLineNo">213</span><a id="line.213">   *</a>
<span class="sourceLineNo">214</span><a id="line.214">   * FluentIterable&lt;? extends Number&gt; numbers = getSomeNumbers();</a>
<span class="sourceLineNo">215</span><a id="line.215">   * Optional&lt;Number&gt; first = (Optional) numbers.first();</a>
<span class="sourceLineNo">216</span><a id="line.216">   * Number value = first.or(0.5); // fine</a>
<span class="sourceLineNo">217</span><a id="line.217">   * }&lt;/pre&gt;</a>
<span class="sourceLineNo">218</span><a id="line.218">   *</a>
<span class="sourceLineNo">219</span><a id="line.219">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method is similar to Java 8's {@code</a>
<span class="sourceLineNo">220</span><a id="line.220">   * Optional.orElse}, but will not accept {@code null} as a {@code defaultValue} ({@link #orNull}</a>
<span class="sourceLineNo">221</span><a id="line.221">   * must be used instead). As a result, the value returned by this method is guaranteed non-null,</a>
<span class="sourceLineNo">222</span><a id="line.222">   * which is not the case for the {@code java.util} equivalent.</a>
<span class="sourceLineNo">223</span><a id="line.223">   */</a>
<span class="sourceLineNo">224</span><a id="line.224">  public abstract T or(T defaultValue);</a>
<span class="sourceLineNo">225</span><a id="line.225"></a>
<span class="sourceLineNo">226</span><a id="line.226">  /**</a>
<span class="sourceLineNo">227</span><a id="line.227">   * Returns this {@code Optional} if it has a value present; {@code secondChoice} otherwise.</a>
<span class="sourceLineNo">228</span><a id="line.228">   *</a>
<span class="sourceLineNo">229</span><a id="line.229">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method has no equivalent in Java 8's</a>
<span class="sourceLineNo">230</span><a id="line.230">   * {@code Optional} class; write {@code thisOptional.isPresent() ? thisOptional : secondChoice}</a>
<span class="sourceLineNo">231</span><a id="line.231">   * instead.</a>
<span class="sourceLineNo">232</span><a id="line.232">   */</a>
<span class="sourceLineNo">233</span><a id="line.233">  public abstract Optional&lt;T&gt; or(Optional&lt;? extends T&gt; secondChoice);</a>
<span class="sourceLineNo">234</span><a id="line.234"></a>
<span class="sourceLineNo">235</span><a id="line.235">  /**</a>
<span class="sourceLineNo">236</span><a id="line.236">   * Returns the contained instance if it is present; {@code supplier.get()} otherwise.</a>
<span class="sourceLineNo">237</span><a id="line.237">   *</a>
<span class="sourceLineNo">238</span><a id="line.238">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method is similar to Java 8's {@code</a>
<span class="sourceLineNo">239</span><a id="line.239">   * Optional.orElseGet}, except when {@code supplier} returns {@code null}. In this case this</a>
<span class="sourceLineNo">240</span><a id="line.240">   * method throws an exception, whereas the Java 8+ method returns the {@code null} to the caller.</a>
<span class="sourceLineNo">241</span><a id="line.241">   *</a>
<span class="sourceLineNo">242</span><a id="line.242">   * @throws NullPointerException if this optional's value is absent and the supplier returns {@code</a>
<span class="sourceLineNo">243</span><a id="line.243">   *     null}</a>
<span class="sourceLineNo">244</span><a id="line.244">   */</a>
<span class="sourceLineNo">245</span><a id="line.245">  public abstract T or(Supplier&lt;? extends T&gt; supplier);</a>
<span class="sourceLineNo">246</span><a id="line.246"></a>
<span class="sourceLineNo">247</span><a id="line.247">  /**</a>
<span class="sourceLineNo">248</span><a id="line.248">   * Returns the contained instance if it is present; {@code null} otherwise. If the instance is</a>
<span class="sourceLineNo">249</span><a id="line.249">   * known to be present, use {@link #get()} instead.</a>
<span class="sourceLineNo">250</span><a id="line.250">   *</a>
<span class="sourceLineNo">251</span><a id="line.251">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method is equivalent to Java 8's</a>
<span class="sourceLineNo">252</span><a id="line.252">   * {@code Optional.orElse(null)}.</a>
<span class="sourceLineNo">253</span><a id="line.253">   */</a>
<span class="sourceLineNo">254</span><a id="line.254">  public abstract @Nullable T orNull();</a>
<span class="sourceLineNo">255</span><a id="line.255"></a>
<span class="sourceLineNo">256</span><a id="line.256">  /**</a>
<span class="sourceLineNo">257</span><a id="line.257">   * Returns an immutable singleton {@link Set} whose only element is the contained instance if it</a>
<span class="sourceLineNo">258</span><a id="line.258">   * is present; an empty immutable {@link Set} otherwise.</a>
<span class="sourceLineNo">259</span><a id="line.259">   *</a>
<span class="sourceLineNo">260</span><a id="line.260">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method has no equivalent in Java 8's</a>
<span class="sourceLineNo">261</span><a id="line.261">   * {@code Optional} class. However, this common usage:</a>
<span class="sourceLineNo">262</span><a id="line.262">   *</a>
<span class="sourceLineNo">263</span><a id="line.263">   * &lt;pre&gt;{@code</a>
<span class="sourceLineNo">264</span><a id="line.264">   * for (Foo foo : possibleFoo.asSet()) {</a>
<span class="sourceLineNo">265</span><a id="line.265">   *   doSomethingWith(foo);</a>
<span class="sourceLineNo">266</span><a id="line.266">   * }</a>
<span class="sourceLineNo">267</span><a id="line.267">   * }&lt;/pre&gt;</a>
<span class="sourceLineNo">268</span><a id="line.268">   *</a>
<span class="sourceLineNo">269</span><a id="line.269">   * ... can be replaced with:</a>
<span class="sourceLineNo">270</span><a id="line.270">   *</a>
<span class="sourceLineNo">271</span><a id="line.271">   * &lt;pre&gt;{@code</a>
<span class="sourceLineNo">272</span><a id="line.272">   * possibleFoo.ifPresent(foo -&gt; doSomethingWith(foo));</a>
<span class="sourceLineNo">273</span><a id="line.273">   * }&lt;/pre&gt;</a>
<span class="sourceLineNo">274</span><a id="line.274">   *</a>
<span class="sourceLineNo">275</span><a id="line.275">   * &lt;p&gt;&lt;b&gt;Java 9 users:&lt;/b&gt; some use cases can be written with calls to {@code optional.stream()}.</a>
<span class="sourceLineNo">276</span><a id="line.276">   *</a>
<span class="sourceLineNo">277</span><a id="line.277">   * @since 11.0</a>
<span class="sourceLineNo">278</span><a id="line.278">   */</a>
<span class="sourceLineNo">279</span><a id="line.279">  public abstract Set&lt;T&gt; asSet();</a>
<span class="sourceLineNo">280</span><a id="line.280"></a>
<span class="sourceLineNo">281</span><a id="line.281">  /**</a>
<span class="sourceLineNo">282</span><a id="line.282">   * If the instance is present, it is transformed with the given {@link Function}; otherwise,</a>
<span class="sourceLineNo">283</span><a id="line.283">   * {@link Optional#absent} is returned.</a>
<span class="sourceLineNo">284</span><a id="line.284">   *</a>
<span class="sourceLineNo">285</span><a id="line.285">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method is similar to Java 8's {@code</a>
<span class="sourceLineNo">286</span><a id="line.286">   * Optional.map}, except when {@code function} returns {@code null}. In this case this method</a>
<span class="sourceLineNo">287</span><a id="line.287">   * throws an exception, whereas the Java 8+ method returns {@code Optional.absent()}.</a>
<span class="sourceLineNo">288</span><a id="line.288">   *</a>
<span class="sourceLineNo">289</span><a id="line.289">   * @throws NullPointerException if the function returns {@code null}</a>
<span class="sourceLineNo">290</span><a id="line.290">   * @since 12.0</a>
<span class="sourceLineNo">291</span><a id="line.291">   */</a>
<span class="sourceLineNo">292</span><a id="line.292">  public abstract &lt;V&gt; Optional&lt;V&gt; transform(Function&lt;? super T, V&gt; function);</a>
<span class="sourceLineNo">293</span><a id="line.293"></a>
<span class="sourceLineNo">294</span><a id="line.294">  /**</a>
<span class="sourceLineNo">295</span><a id="line.295">   * Returns {@code true} if {@code object} is an {@code Optional} instance, and either the</a>
<span class="sourceLineNo">296</span><a id="line.296">   * contained references are {@linkplain Object#equals equal} to each other or both are absent.</a>
<span class="sourceLineNo">297</span><a id="line.297">   * Note that {@code Optional} instances of differing parameterized types can be equal.</a>
<span class="sourceLineNo">298</span><a id="line.298">   *</a>
<span class="sourceLineNo">299</span><a id="line.299">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; no differences.</a>
<span class="sourceLineNo">300</span><a id="line.300">   */</a>
<span class="sourceLineNo">301</span><a id="line.301">  @Override</a>
<span class="sourceLineNo">302</span><a id="line.302">  public abstract boolean equals(@Nullable Object object);</a>
<span class="sourceLineNo">303</span><a id="line.303"></a>
<span class="sourceLineNo">304</span><a id="line.304">  /**</a>
<span class="sourceLineNo">305</span><a id="line.305">   * Returns a hash code for this instance.</a>
<span class="sourceLineNo">306</span><a id="line.306">   *</a>
<span class="sourceLineNo">307</span><a id="line.307">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this class leaves the specific choice of</a>
<span class="sourceLineNo">308</span><a id="line.308">   * hash code unspecified, unlike the Java 8+ equivalent.</a>
<span class="sourceLineNo">309</span><a id="line.309">   */</a>
<span class="sourceLineNo">310</span><a id="line.310">  @Override</a>
<span class="sourceLineNo">311</span><a id="line.311">  public abstract int hashCode();</a>
<span class="sourceLineNo">312</span><a id="line.312"></a>
<span class="sourceLineNo">313</span><a id="line.313">  /**</a>
<span class="sourceLineNo">314</span><a id="line.314">   * Returns a string representation for this instance.</a>
<span class="sourceLineNo">315</span><a id="line.315">   *</a>
<span class="sourceLineNo">316</span><a id="line.316">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this class leaves the specific string</a>
<span class="sourceLineNo">317</span><a id="line.317">   * representation unspecified, unlike the Java 8+ equivalent.</a>
<span class="sourceLineNo">318</span><a id="line.318">   */</a>
<span class="sourceLineNo">319</span><a id="line.319">  @Override</a>
<span class="sourceLineNo">320</span><a id="line.320">  public abstract String toString();</a>
<span class="sourceLineNo">321</span><a id="line.321"></a>
<span class="sourceLineNo">322</span><a id="line.322">  /**</a>
<span class="sourceLineNo">323</span><a id="line.323">   * Returns the value of each present instance from the supplied {@code optionals}, in order,</a>
<span class="sourceLineNo">324</span><a id="line.324">   * skipping over occurrences of {@link Optional#absent}. Iterators are unmodifiable and are</a>
<span class="sourceLineNo">325</span><a id="line.325">   * evaluated lazily.</a>
<span class="sourceLineNo">326</span><a id="line.326">   *</a>
<span class="sourceLineNo">327</span><a id="line.327">   * &lt;p&gt;&lt;b&gt;Comparison to {@code java.util.Optional}:&lt;/b&gt; this method has no equivalent in Java 8's</a>
<span class="sourceLineNo">328</span><a id="line.328">   * {@code Optional} class; use {@code</a>
<span class="sourceLineNo">329</span><a id="line.329">   * optionals.stream().filter(Optional::isPresent).map(Optional::get)} instead.</a>
<span class="sourceLineNo">330</span><a id="line.330">   *</a>
<span class="sourceLineNo">331</span><a id="line.331">   * &lt;p&gt;&lt;b&gt;Java 9 users:&lt;/b&gt; use {@code optionals.stream().flatMap(Optional::stream)} instead.</a>
<span class="sourceLineNo">332</span><a id="line.332">   *</a>
<span class="sourceLineNo">333</span><a id="line.333">   * @since 11.0 (generics widened in 13.0)</a>
<span class="sourceLineNo">334</span><a id="line.334">   */</a>
<span class="sourceLineNo">335</span><a id="line.335">  public static &lt;T&gt; Iterable&lt;T&gt; presentInstances(</a>
<span class="sourceLineNo">336</span><a id="line.336">      final Iterable&lt;? extends Optional&lt;? extends T&gt;&gt; optionals) {</a>
<span class="sourceLineNo">337</span><a id="line.337">    checkNotNull(optionals);</a>
<span class="sourceLineNo">338</span><a id="line.338">    return new Iterable&lt;T&gt;() {</a>
<span class="sourceLineNo">339</span><a id="line.339">      @Override</a>
<span class="sourceLineNo">340</span><a id="line.340">      public Iterator&lt;T&gt; iterator() {</a>
<span class="sourceLineNo">341</span><a id="line.341">        return new AbstractIterator&lt;T&gt;() {</a>
<span class="sourceLineNo">342</span><a id="line.342">          private final Iterator&lt;? extends Optional&lt;? extends T&gt;&gt; iterator =</a>
<span class="sourceLineNo">343</span><a id="line.343">              checkNotNull(optionals.iterator());</a>
<span class="sourceLineNo">344</span><a id="line.344"></a>
<span class="sourceLineNo">345</span><a id="line.345">          @Override</a>
<span class="sourceLineNo">346</span><a id="line.346">          protected @Nullable T computeNext() {</a>
<span class="sourceLineNo">347</span><a id="line.347">            while (iterator.hasNext()) {</a>
<span class="sourceLineNo">348</span><a id="line.348">              Optional&lt;? extends T&gt; optional = iterator.next();</a>
<span class="sourceLineNo">349</span><a id="line.349">              if (optional.isPresent()) {</a>
<span class="sourceLineNo">350</span><a id="line.350">                return optional.get();</a>
<span class="sourceLineNo">351</span><a id="line.351">              }</a>
<span class="sourceLineNo">352</span><a id="line.352">            }</a>
<span class="sourceLineNo">353</span><a id="line.353">            return endOfData();</a>
<span class="sourceLineNo">354</span><a id="line.354">          }</a>
<span class="sourceLineNo">355</span><a id="line.355">        };</a>
<span class="sourceLineNo">356</span><a id="line.356">      }</a>
<span class="sourceLineNo">357</span><a id="line.357">    };</a>
<span class="sourceLineNo">358</span><a id="line.358">  }</a>
<span class="sourceLineNo">359</span><a id="line.359"></a>
<span class="sourceLineNo">360</span><a id="line.360">  private static final long serialVersionUID = 0;</a>
<span class="sourceLineNo">361</span><a id="line.361">}</a>




























































</pre>
</div>
</main>
</body>
</html>
